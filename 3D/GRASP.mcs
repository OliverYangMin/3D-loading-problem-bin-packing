require 'Box'
require 'Layer'
require 'Space'
require 'functions'

max_iter = 5000
K = 0.5

function constructive(Pnum, delta)
    local used_volume, memory, ready = 0, {}, false
    empty, boxes, packed = {container}, {}, {}
    for i=1,#problems[Pnum] do 
        boxes[#boxes+1] = Box:new(unpack(problems[Pnum][i])) 
    end
 
    repeat
        table.sort(empty, compareSpace)             
        local layer = empty[1]:chooseLayer(delta)    
        if not layer then break end
        empty[1]:setLayerPosition(layer)                        
        packed[#packed+1] = layer
        boxes[layer.tp]:reduce(layer.num)
        used_volume = used_volume + layer.volume
     
        local spaces = empty[1]:createMaxSpace(layer) 
        table.remove(empty, 1) 
        
        layer:updateRemainingEmpty()   
        
        for s=1,#spaces do 
            if not spaces[s]:isBeContainedByEmpty() then
                empty[#empty+1] = spaces[s] 
            end
        end --- 检验2 是否被其他空间包围
        
        if not ready and used_volume / container.volume > 0.5 then
            ready = true
            memory.packed = DeepCopy(packed)
            memory.boxes = DeepCopy(boxes)
            memory.empty = DeepCopy(empty)
            memory.used_volume = used_volume
        end
    until isNoLeft() or #empty == 0 
    --print('Grasp:', used_volume/container.volume)
    return used_volume/container.volume, memory
end 

function improvement(memory)
   packed = memory.packed
   empty  = memory.empty
   boxes = memory.boxes
   local used_volume = memory.used_volume
   repeat
        table.sort(empty, compareSpace)             
        local layer = empty[1]:chooseBestLayer()  
        if layer.volume == 0 then break end
        empty[1]:setLayerPosition(layer)                        
        boxes[layer.tp]:reduce(layer.num)
        used_volume = used_volume + layer.volume

        local spaces = empty[1]:createMaxSpace(layer) 
        table.remove(empty, 1) 

        layer:updateRemainingEmpty()   

        for s=1,#spaces do 
            if not spaces[s]:isBeContainedByEmpty() then
                empty[#empty+1] = spaces[s] 
            end
        end --- 检验2 是否被其他空间包围
    until isNoLeft() or #empty == 0 
    print('improve:', used_volume/container.volume)
    return used_volume / container.volume
end

function chooseDelta()
    local r = math.random()
    local p = deltas[1].p
    for i=1,9 do
        if r <= p then
            return i
        end
        p = p + deltas[i+1].p
    end -- 需要检查是否所有的delta都被用到了，尤其是9
end

function reactiveGRASP(Pnum)
    deltas = {}
    for i=1,9 do deltas[i] = {0.1 * i; count = 0, sum = 0, p = 1 / 9, eval = 0} end  
    local Vbest, Vworst = 0, math.huge
    bestSolution = {}
    for iter=1,max_iter do
        SetProgress(iter, max_iter)
        local n = chooseDelta()
        deltas[n].count = deltas[n].count + 1
        local V, memory, Vstar = constructive(Pnum, deltas[n])
        if V >= Vworst + 0.5 * (Vbest - Vworst) then
            local v = improvement(memory)
            Vstar = v > V and v or V
        else
            Vstar = V
        end
        if Vstar > Vbest  then 
            Vbest  = Vstar 
            bestSolution = DeepCopy(packed)
        end 
        if Vstar < Vworst then Vworst = Vstar end 
       
        deltas[n].sum = deltas[n].sum + Vstar
        
        if iter % 500 == 0 then
            local sum_eval = 0
            for i=1,9 do
                deltas[i].eval = ((deltas[i].sum/iter - Vworst) / (Vbest - Vworst)) ^ 10
                sum_eval = sum_eval + deltas[i].eval
            end 
            for i=1,9 do
                deltas[i].p = deltas[i].eval / sum_eval 
            end
        end 
    end 
    print(Vbest, ' ',Vworst)
    for i=1,#deltas do
        print(deltas[i].p)
    end 
end 

function grasp_main()
    local starttime = os.time()
    math.randomseed(7)
    readBischooff(7)
    container = Space:new({0, 0, 0}, {W, H, D}, true)
    for p=1,1 do --PSIZE do
        reactiveGRASP(p)
    end 
    print('CPU time: ', os.time() - starttime)
end

grasp_main()